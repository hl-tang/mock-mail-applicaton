{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\n// src/core/normalize.ts\nfunction isObject(v) {\n  return typeof v === \"object\" && v !== null;\n}\nfunction identity(v) {\n  return v;\n}\nfunction normalizeOptions(options, factoryOptions) {\n  options = isObject(options) ? options : /* @__PURE__ */Object.create(null);\n  return new Proxy(options, {\n    get(target, key, receiver) {\n      var _a;\n      if (key === \"key\") {\n        return ((_a = factoryOptions.key) != null ? _a : identity)(Reflect.get(target, key, receiver));\n      }\n      return Reflect.get(target, key, receiver) || Reflect.get(factoryOptions, key, receiver);\n    }\n  });\n}\n\n// src/core/pick.ts\nfunction isObject2(value) {\n  return value !== null && typeof value === \"object\";\n}\nfunction merge(destination, source) {\n  const mergingArrays = Array.isArray(destination) && Array.isArray(source);\n  const mergingObjects = isObject2(destination) && isObject2(source);\n  if (!mergingArrays && !mergingObjects) {\n    throw new Error(\"Can only merge object with object or array with array\");\n  }\n  const result = mergingArrays ? [] : {};\n  const keys = [...Object.keys(destination), ...Object.keys(source)];\n  keys.forEach(key => {\n    if (Array.isArray(destination[key]) && Array.isArray(source[key])) {\n      result[key] = [...Object.values(merge(destination[key], source[key]))];\n    } else if (source[key] !== null && typeof source[key] === \"object\" && typeof destination[key] === \"object\") {\n      result[key] = merge(destination[key], source[key]);\n    } else if (destination[key] !== void 0 && source[key] === void 0) {\n      result[key] = destination[key];\n    } else if (destination[key] === void 0 && source[key] !== void 0) {\n      result[key] = source[key];\n    }\n  });\n  return result;\n}\nfunction get(state, path) {\n  return path.reduce((obj, p) => {\n    if (p === \"[]\" && Array.isArray(obj)) return obj;\n    return obj == null ? void 0 : obj[p];\n  }, state);\n}\nfunction set(state, path, val) {\n  const modifiedState = path.slice(0, -1).reduce((obj, p) => {\n    if (!/^(__proto__)$/.test(p)) return obj[p] = obj[p] || {};else return {};\n  }, state);\n  if (Array.isArray(modifiedState[path[path.length - 1]]) && Array.isArray(val)) {\n    const merged = modifiedState[path[path.length - 1]].map((item, index) => {\n      if (Array.isArray(item) && typeof item !== \"object\") {\n        return [...item, ...val[index]];\n      }\n      if (typeof item === \"object\" && item !== null && Object.keys(item).some(key => Array.isArray(item[key]))) {\n        return merge(item, val[index]);\n      }\n      return __spreadValues(__spreadValues({}, item), val[index]);\n    });\n    modifiedState[path[path.length - 1]] = merged;\n  } else if (path[path.length - 1] === void 0 && Array.isArray(modifiedState) && Array.isArray(val)) {\n    modifiedState.push(...val);\n  } else {\n    modifiedState[path[path.length - 1]] = val;\n  }\n  return state;\n}\nfunction pick(baseState, paths) {\n  return paths.reduce((substate, path) => {\n    const pathArray = path.split(\".\");\n    if (!pathArray.includes(\"[]\")) {\n      return set(substate, pathArray, get(baseState, pathArray));\n    }\n    const arrayIndex = pathArray.indexOf(\"[]\");\n    const pathArrayBeforeArray = pathArray.slice(0, arrayIndex);\n    const pathArrayUntilArray = pathArray.slice(0, arrayIndex + 1);\n    const pathArrayAfterArray = pathArray.slice(arrayIndex + 1);\n    const referencedArray = get(baseState, pathArrayUntilArray);\n    const referencedArraySubstate = [];\n    for (const item of referencedArray) {\n      if (pathArrayAfterArray.length !== 0 && (Array.isArray(item) || typeof item === \"object\")) {\n        referencedArraySubstate.push(pick(item, [pathArrayAfterArray.join(\".\")]));\n      } else {\n        referencedArraySubstate.push(item);\n      }\n    }\n    return set(substate, pathArrayBeforeArray, referencedArraySubstate);\n  }, Array.isArray(baseState) ? [] : {});\n}\n\n// src/core/plugin.ts\nfunction hydrateStore(store, storage, serializer, key, debug) {\n  try {\n    const fromStorage = storage == null ? void 0 : storage.getItem(key);\n    if (fromStorage) store.$patch(serializer == null ? void 0 : serializer.deserialize(fromStorage));\n  } catch (error) {\n    if (debug) console.error(error);\n  }\n}\nfunction createPersistedState(factoryOptions = {}) {\n  return context => {\n    const {\n      options: {\n        persist\n      },\n      store\n    } = context;\n    if (!persist) return;\n    const persistences = (Array.isArray(persist) ? persist.map(p => normalizeOptions(p, factoryOptions)) : [normalizeOptions(persist, factoryOptions)]).map(({\n      storage = localStorage,\n      beforeRestore = null,\n      afterRestore = null,\n      serializer = {\n        serialize: JSON.stringify,\n        deserialize: JSON.parse\n      },\n      key = store.$id,\n      paths = null,\n      debug = false\n    }) => ({\n      storage,\n      beforeRestore,\n      afterRestore,\n      serializer,\n      key,\n      paths,\n      debug\n    }));\n    persistences.forEach(persistence => {\n      const {\n        storage,\n        serializer,\n        key,\n        paths,\n        beforeRestore,\n        afterRestore,\n        debug\n      } = persistence;\n      beforeRestore == null ? void 0 : beforeRestore(context);\n      hydrateStore(store, storage, serializer, key, debug);\n      afterRestore == null ? void 0 : afterRestore(context);\n      store.$subscribe((_mutation, state) => {\n        try {\n          const toStore = Array.isArray(paths) ? pick(state, paths) : state;\n          storage.setItem(key, serializer.serialize(toStore));\n        } catch (error) {\n          if (debug) console.error(error);\n        }\n      }, {\n        detached: true\n      });\n    });\n    store.$hydrate = ({\n      runHooks = true\n    } = {}) => {\n      persistences.forEach(persistence => {\n        const {\n          beforeRestore,\n          afterRestore,\n          storage,\n          serializer,\n          key,\n          debug\n        } = persistence;\n        if (runHooks) beforeRestore == null ? void 0 : beforeRestore(context);\n        hydrateStore(store, storage, serializer, key, debug);\n        if (runHooks) afterRestore == null ? void 0 : afterRestore(context);\n      });\n    };\n  };\n}\nexport { __spreadValues, createPersistedState };","map":{"version":3,"names":["__defProp","Object","defineProperty","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","prototype","hasOwnProperty","__propIsEnum","propertyIsEnumerable","__defNormalProp","obj","key","value","enumerable","configurable","writable","__spreadValues","a","b","prop","call","isObject","v","identity","normalizeOptions","options","factoryOptions","create","Proxy","get","target","receiver","_a","Reflect","isObject2","merge","destination","source","mergingArrays","Array","isArray","mergingObjects","Error","result","keys","forEach","values","state","path","reduce","p","set","val","modifiedState","slice","test","length","merged","map","item","index","some","push","pick","baseState","paths","substate","pathArray","split","includes","arrayIndex","indexOf","pathArrayBeforeArray","pathArrayUntilArray","pathArrayAfterArray","referencedArray","referencedArraySubstate","join","hydrateStore","store","storage","serializer","debug","fromStorage","getItem","$patch","deserialize","error","console","createPersistedState","context","persist","persistences","localStorage","beforeRestore","afterRestore","serialize","JSON","stringify","parse","$id","persistence","$subscribe","_mutation","toStore","setItem","detached","$hydrate","runHooks"],"sources":["/home/hl_tang/Code/VSCodeWorkSpace/gmail-clone/node_modules/pinia-plugin-persistedstate/dist/chunk-256H5QT7.mjs"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\n\n// src/core/normalize.ts\nfunction isObject(v) {\n  return typeof v === \"object\" && v !== null;\n}\nfunction identity(v) {\n  return v;\n}\nfunction normalizeOptions(options, factoryOptions) {\n  options = isObject(options) ? options : /* @__PURE__ */ Object.create(null);\n  return new Proxy(options, {\n    get(target, key, receiver) {\n      var _a;\n      if (key === \"key\") {\n        return ((_a = factoryOptions.key) != null ? _a : identity)(\n          Reflect.get(target, key, receiver)\n        );\n      }\n      return Reflect.get(target, key, receiver) || Reflect.get(factoryOptions, key, receiver);\n    }\n  });\n}\n\n// src/core/pick.ts\nfunction isObject2(value) {\n  return value !== null && typeof value === \"object\";\n}\nfunction merge(destination, source) {\n  const mergingArrays = Array.isArray(destination) && Array.isArray(source);\n  const mergingObjects = isObject2(destination) && isObject2(source);\n  if (!mergingArrays && !mergingObjects) {\n    throw new Error(\"Can only merge object with object or array with array\");\n  }\n  const result = mergingArrays ? [] : {};\n  const keys = [...Object.keys(destination), ...Object.keys(source)];\n  keys.forEach((key) => {\n    if (Array.isArray(destination[key]) && Array.isArray(source[key])) {\n      result[key] = [\n        ...Object.values(\n          merge(destination[key], source[key])\n        )\n      ];\n    } else if (source[key] !== null && typeof source[key] === \"object\" && typeof destination[key] === \"object\") {\n      result[key] = merge(\n        destination[key],\n        source[key]\n      );\n    } else if (destination[key] !== void 0 && source[key] === void 0) {\n      result[key] = destination[key];\n    } else if (destination[key] === void 0 && source[key] !== void 0) {\n      result[key] = source[key];\n    }\n  });\n  return result;\n}\nfunction get(state, path) {\n  return path.reduce((obj, p) => {\n    if (p === \"[]\" && Array.isArray(obj))\n      return obj;\n    return obj == null ? void 0 : obj[p];\n  }, state);\n}\nfunction set(state, path, val) {\n  const modifiedState = path.slice(0, -1).reduce((obj, p) => {\n    if (!/^(__proto__)$/.test(p))\n      return obj[p] = obj[p] || {};\n    else\n      return {};\n  }, state);\n  if (Array.isArray(modifiedState[path[path.length - 1]]) && Array.isArray(val)) {\n    const merged = modifiedState[path[path.length - 1]].map(\n      (item, index) => {\n        if (Array.isArray(item) && typeof item !== \"object\") {\n          return [...item, ...val[index]];\n        }\n        if (typeof item === \"object\" && item !== null && Object.keys(item).some((key) => Array.isArray(item[key]))) {\n          return merge(item, val[index]);\n        }\n        return __spreadValues(__spreadValues({}, item), val[index]);\n      }\n    );\n    modifiedState[path[path.length - 1]] = merged;\n  } else if (path[path.length - 1] === void 0 && Array.isArray(modifiedState) && Array.isArray(val)) {\n    modifiedState.push(...val);\n  } else {\n    modifiedState[path[path.length - 1]] = val;\n  }\n  return state;\n}\nfunction pick(baseState, paths) {\n  return paths.reduce(\n    (substate, path) => {\n      const pathArray = path.split(\".\");\n      if (!pathArray.includes(\"[]\")) {\n        return set(substate, pathArray, get(baseState, pathArray));\n      }\n      const arrayIndex = pathArray.indexOf(\"[]\");\n      const pathArrayBeforeArray = pathArray.slice(0, arrayIndex);\n      const pathArrayUntilArray = pathArray.slice(0, arrayIndex + 1);\n      const pathArrayAfterArray = pathArray.slice(arrayIndex + 1);\n      const referencedArray = get(\n        baseState,\n        pathArrayUntilArray\n      );\n      const referencedArraySubstate = [];\n      for (const item of referencedArray) {\n        if (pathArrayAfterArray.length !== 0 && (Array.isArray(item) || typeof item === \"object\")) {\n          referencedArraySubstate.push(\n            pick(item, [pathArrayAfterArray.join(\".\")])\n          );\n        } else {\n          referencedArraySubstate.push(item);\n        }\n      }\n      return set(substate, pathArrayBeforeArray, referencedArraySubstate);\n    },\n    Array.isArray(baseState) ? [] : {}\n  );\n}\n\n// src/core/plugin.ts\nfunction hydrateStore(store, storage, serializer, key, debug) {\n  try {\n    const fromStorage = storage == null ? void 0 : storage.getItem(key);\n    if (fromStorage)\n      store.$patch(serializer == null ? void 0 : serializer.deserialize(fromStorage));\n  } catch (error) {\n    if (debug)\n      console.error(error);\n  }\n}\nfunction createPersistedState(factoryOptions = {}) {\n  return (context) => {\n    const {\n      options: { persist },\n      store\n    } = context;\n    if (!persist)\n      return;\n    const persistences = (Array.isArray(persist) ? persist.map((p) => normalizeOptions(p, factoryOptions)) : [normalizeOptions(persist, factoryOptions)]).map(\n      ({\n        storage = localStorage,\n        beforeRestore = null,\n        afterRestore = null,\n        serializer = {\n          serialize: JSON.stringify,\n          deserialize: JSON.parse\n        },\n        key = store.$id,\n        paths = null,\n        debug = false\n      }) => ({\n        storage,\n        beforeRestore,\n        afterRestore,\n        serializer,\n        key,\n        paths,\n        debug\n      })\n    );\n    persistences.forEach((persistence) => {\n      const {\n        storage,\n        serializer,\n        key,\n        paths,\n        beforeRestore,\n        afterRestore,\n        debug\n      } = persistence;\n      beforeRestore == null ? void 0 : beforeRestore(context);\n      hydrateStore(store, storage, serializer, key, debug);\n      afterRestore == null ? void 0 : afterRestore(context);\n      store.$subscribe(\n        (_mutation, state) => {\n          try {\n            const toStore = Array.isArray(paths) ? pick(state, paths) : state;\n            storage.setItem(key, serializer.serialize(toStore));\n          } catch (error) {\n            if (debug)\n              console.error(error);\n          }\n        },\n        {\n          detached: true\n        }\n      );\n    });\n    store.$hydrate = ({ runHooks = true } = {}) => {\n      persistences.forEach((persistence) => {\n        const { beforeRestore, afterRestore, storage, serializer, key, debug } = persistence;\n        if (runHooks)\n          beforeRestore == null ? void 0 : beforeRestore(context);\n        hydrateStore(store, storage, serializer, key, debug);\n        if (runHooks)\n          afterRestore == null ? void 0 : afterRestore(context);\n      });\n    };\n  };\n}\n\nexport {\n  __spreadValues,\n  createPersistedState\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}